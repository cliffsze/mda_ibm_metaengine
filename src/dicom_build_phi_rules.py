import os
import datetime
import ConfigParser
import collections
import csv


# Filename : dicom_build_phi_rules.py
# Purpose  : construct phi rules py file
# Params   :
#
# Inputs - cad_config.conf parameters:
#   [dicom]
#   source_dicom_dictionary
#   source_dicom_phi_rules
#
# Outputs - create executable rules file
#   dicom_phi_rules.py
#   dicom.phi_rules.kfb (Pyke)
#
# Change Log:
# 20150613 - initial release
# 20150702 - convert all lookup to be case insensitive (change to lowercase before compare)
#        tag - converted to lowercase alphabets
#        name (key in dd dict) - converted to all lowercase
#        anonymization_policy - converted all lowercase before append to dict
# 21050702 - is_phi attribute converted to boolean value before append to dict
# 20150706 - changed dicon dictionary file format to csv - [Tag] [Name] [Keyword] [VR] [VM]
# 20150713 - write output to kfb formatted file for Pyke rules engine
#
#
# main program
#
#
# get configuration parameters
home_dir = os.path.dirname(os.path.realpath(__file__))
config_file = home_dir + '/' + 'cad_config.conf'
c = ConfigParser.SafeConfigParser()
c.read(config_file)
dicom_dictionary = c.get('dicom', 'source_dicom_dictionary')
phi_rules_file = c.get('dicom', 'source_dicom_phi_rules')
output_py_file = "dicom_phi_rules.py"
output_kfb_file = "dicom_phi_rules.kfb"

print "home directory: " + home_dir
print "input files: " + dicom_dictionary +", " + phi_rules_file
print "output files: " + output_py_file + ", " + output_kfb_file

dicom_dictionary = home_dir + "/" + dicom_dictionary
phi_rules_file   = home_dir + "/" + phi_rules_file
output_py_file   = home_dir + "/" + output_py_file
output_kfb_file  = home_dir + "/" + output_kfb_file


# read dicom dictionary file into dd dictionary
dd = collections.defaultdict(list)
f = open(dicom_dictionary,'r')
reader = csv.reader(f)

count = 0
for row in reader:
    if row[0].lower() == 'tag' or row[0] == '':
        # skip blank line or comments
        pass
    else:
        # Format: [Tag] [Name] [Keyword] [VR] [VM] - csv
        # key = [Keyword] (lowercase), value = [Tag] [VR] [VM]
        value = row[0] + "\t" + row[3] + "\t" + row[4]
        dd[row[2].lower()].append(value)
        count += 1
        
f.close()
print dicom_dictionary + " - tags read: " + str(count)


# rename old py rules file if exist - add date as file extension
now = datetime.datetime.now()
if os.path.isfile(output_py_file):
    ext = now.strftime('.%y%m%d.%H%M')
    renam = output_py_file + ext
    os.rename(output_py_file, renam)


# delete old kfb rules file if exist
if os.path.isfile(output_kfb_file):
    os.remove(output_kfb_file)
    print "old " + output_kfb_file + " file deleted"


# open new output file dicom_phi_rules.py and dicom_phi_rules.kfb
fo = open(output_py_file,'w')
fp = open(output_kfb_file,'w')
count = 0
py_header = (
    "# Filename : " + output_py_file + "\n" 
  + "# Purpose  : dicom phi rules auto generated by " + os.path.basename(__file__) + "\n"
  + "# Creation Date: " + str(now) + "\n\n"
  + "import collections\n"
  + "def init_phi_dict():\n"
  + "    dict = collections.defaultdict(list)\n")
fo.write(py_header)

py_header = (
    "# Filename : " + output_kfb_file + "\n"
  + "# Purpose  : dicom phi rules auto generated by " + os.path.basename(__file__) + "\n"
  + "# Creation Date: " + str(now) + "\n\n")
fp.write(py_header)


# read dicom phi rules csv file
# Format: [Name],[IsPHI],[Anonymization Policy]
fi = open (phi_rules_file, 'r')
reader = csv.reader(fi)
for row in reader:
    
    # match the phi rule name to a dd item (use all lowercase)
    name = row[0].rstrip()
    value = dd[name.lower()]

    if not value:
        # phi rule name does not match any dicom dictionary name
        fo.write("    # name not found: " + name + "\n")
        fp.write("    # name not found: " + name + "\n")

    else:
        # set warning message if dicom dictionary has duplicate names
        comment = ''
        i = len(value)
        if i > 1:
            comment = "    # dicom.dic has " + str(i) + " tags with same name: " + name

        # extract attributes from matching dd line
        # Format: [Tag] [VR] [VM] - tab delimited
        attr = value[0].split('\t')
        tag = attr[0].lower()
        vr  = attr[1]
        vm  = attr[2]
        
        b = row[1].rstrip().capitalize()
        if b == "False":
            is_phi = False
        else:
            is_phi = True
        anonymization_policy = row[2].rstrip().lower()


        # format py formatted output list object
        # Format: [Name] [VR] [VM] [version] [is_phi] [anonymization_rule]
        out = list()
        #out.append(tag)
        out.append(name)
        out.append(vr)
        out.append(vm)
        out.append(' ')
        out.append(is_phi)
        out.append(anonymization_policy)

        fo.write("    dict['" + tag + "'].append(")
        fo.write(str(out))
        fo.write(")\n")


        # format kfb formatted output line
        # universal_fact_is_phi(tag, name, anonmizaton_policy)
        # universal_fact_not_phi(tag, name, anonmizaton_policy)
        if is_phi:
            fp.write("    universal_fact_is_phi('" 
                     + tag + "', '" 
                     + name + "', '"
                     + anonymization_policy + "')\n")
        else:
            fp.write("    universal_fact_not_phi('" 
                     + tag + "', '" 
                     + name + "', '"
                     + anonymization_policy + "')\n")
    
        count += 1
        if len(comment) > 0:
            fo.write(comment + "\n")
            fp.write(comment + "\n")


fo.write("    return dict\n\n")
fo.write("    # " + str(count) + " tags written\n")
fp.write("    # " + str(count) + " tags written\n")

print "tags written: " + str(count)
fi.close()
fo.close()
fp.close()

